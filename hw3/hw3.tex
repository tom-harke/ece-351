\documentclass{article}
\usepackage{circuitikz}
\usepackage{fancyvrb}
\usepackage{enumitem}
\usepackage{pdfpages}
\usepackage{multicol}
%\usepackage[hscale=0.7,vscale=0.8]{geometry}
\usepackage[margin=1.5cm]{geometry}


\setlength{\parindent}{0pt}

\title{ECE 351 HW 3}
\date{2024 Nov 27}
\author{Tom Harke}
%\setlength{\columnseprule}{.4pt}


\begin{document}
\maketitle

\begin{multicols}{2}

\section{TODO}
\begin{itemize}
\item test that memory is larger than immediates
\item test divide-by-zero
\item test overflow
\item test stack size
\item test stack empty
\item test stack full
\end{itemize}
\section{Design}
I've merged a number of states from the suggested FSM, and slightly changed the meaning of the POP/PUSH states.
The reason for merging is that we don't need that many
	-- we only need enough so that we can sequence the flow of separate pieces of stack data on separate clock cycle.
With my compressed FSM the meaning of state\dots
\begin{description}[noitemsep]
\item[POP2] is that 2nd argument (if any) has already been popped off the stack
\item[POP1] is that 1st argument (if any) has already been popped off the stack
\item[PUSH] is that result has already been pushed onto the stack
\end{description}
Note that each of these is in the past tense.

I'll try to motivate a simpler 3-state FSM by
examining the constraints on how the CPU moves data
around -- specifically, focussing on what needs to be
registered, and leaving the rest to combinational logic.

The longest chain of register updates is for processsing
a binary operation.
For concreteness we'll focus on 4+3, as all other instances
are isomorphic (modulo error detection due
to divide-by-zero or overflow).

The operation 4+3 arises in the context of the next op being
\verb'ADD' and with a stack of the form:
\begin{center}
	$4:3:\sigma$
\end{center}
where $4$ is at the top of the stack, $3$ is next-to-top,
and $\sigma$ represents the rest of the stack

In this context the stack changes state
\begin{center} $4:3:\sigma$ \end{center}
\begin{center}   $3:\sigma$ \end{center}
\begin{center}     $\sigma$ \end{center}
\begin{center}   $7:\sigma$ \end{center}

We need to have each change on a clock edge so we can pop or push.
\section{Finite State Machine}\
TODO
\section{Timing}

All binary ops (\verb'+',\verb'-',\verb'*',\verb'/',\verb'\%',\verb'\&',\verb'|')
follow this timing example.

The stack is included in the diagram, even though it's more than a register,
using the notation from above (eg $3:4:\sigma$).
\includegraphics[scale=1.0]{add.timing.pdf}
The \verb'invert' op follows this timing example
\includegraphics[scale=1.0]{inv.timing.pdf}
The \verb'push_immediate' op follows this timing example
\includegraphics[scale=1.0]{imm.timing.pdf}

\section{Etc}
\subsection{Etc}
I spent a lot of time drawing timing diagrams before I started coding.
Midway through, I wondered if I'd just wasted all that time, but when I started coding, it was a breeze.
\subsection{Technology}
Timing diagrams were typeset with ease using the \LaTeX\ package \verb'tikz-timing' 
\subsection{Etc}
Next time you offer this assignment, drop the logical operators, add an arithmetic unary negation operator.
The only thing logic ops add is the unary operator, and they have the cost of ... TODO

\end{multicols}
\end{document}
